section	.text
   global _start     ;must be declared for linker (ld)
	
_start:	            ;tells linker entry point
   mov	edx,len     ;message length
   mov	ecx,msg     ;message to write
   mov	ebx,1       ;file descriptor (stdout)
   mov	eax,4       ;system call number (sys_write)
   int	0x80        ;call kernel
	
   mov	eax,1       ;system call number (sys_exit)
   int	0x80        ;call kernel

section	.data
msg db 'Hello, world!', 0xa  ;string to be printed
len equ $ - msg     ;length of the string

There are ten 32-bit and six 16-bit processor registers in IA-32 architecture. The registers are grouped into three categories −

General registers,
Control registers, and
Segment registers.
The general registers are further divided into the following groups −

Data registers,
Pointer registers, and
Index registers.

https://www.tutorialspoint.com/assembly_programming/assembly_registers.htm



%rax, %rbx, %rcx, %rdx, %rdi, %rsi, %rbp,
%rsp, and %r8-r15. Of these, %rax, %rcx, %rdx, %rdi, %rsi, %rsp, and %r8-r11 Are not saved between function calls. Volatile, don't have to ve pushed/popped

registers %rbx, %rbp, and %r12-r15 are saved after functions finish. Must push/pop

%rsp is the stack pointer to the topmost element of the stack


; section .data <- for declaring consts
; section .bss <- for declaring variables

; use rcx to iterate

; You can't move anything from memory to memory, but need to use a temporary register

The byte for rax is stored inside al, so if you want the char, move al to rax, even if its already there

movsx moves a byte to a qword (if those are the right words)

RBX, RBP, RDI, RSI, R12, R14, R14, and R15 must be saved in any function using them.


RAX, RCX, RDX, R8, R9, R10, and R11 are considered volatile and must be considered destroyed on function calls.


Syscall
Func    Param 1	Param 2	Param 3	Param 4	Param 5	Param 6
rax     rdi	    rsi	    rdx	    r10	    r8	    r9


2

Yes, in the System V ABI, the stack is aligned to a 16-byte boundary before every call instruction. Thus, on function entry it takes another 8 bytes (not 1) to reach the next 16-byte boundary. Remember that in C, pointer differences are scaled by sizeof(type), but in asm they aren't.

And yes, push rax / pop rcx would be a good choice, and is what clang / LLVM does if it doesn't already need to push an odd number of call-preserved registers or reserve any extra stack space. If you do need to reserve any stack space for locals, use an offset that will leave rsp 16-byte aligned.